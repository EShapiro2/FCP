/*
     
CS 442: Concurrent Prolog Programming Techniques
     
Instructor:  Ehud Shapiro
TAs:      Simran Singh,  Simran@sushi
          Tom Strat, Strat@sri-ai
     
Handout No. 10,  Thursday,  November 20th, 1986
     
     
This handout contains the simple mailer shown in class,
and an advanced mailer.
The advanced mailer is given as an example of what a project
can look like.  Note that this is a relatively short program,
but with sophisticated functionality.
A possible extension of it is to dynamically add multiple
subscribers, using the concept of dynamic merge trees
(the mailer would then be like a club in which only members
can let new memgers in).
     
     
An application: a simple mailer
     
mailer(Subscribers) :-
          Subscribers is a list of terms channel(In,Out),
          for every subscriber to the mail service.
          Messages are of the form message(To,From,Contents),
          where To is a list of binary digits, From
          and Content are arbitrary.
     
*/
     
     
mailer(Subscribers) :-
          tree(Subscribers?,Root),
          route(Root?).
     
route(channel(X,X)).
     
tree([X1,X2|Bottom],Top) :-
          layer([X1,X2|Bottom],Bottom1),
          tree(Bottom1?,Top).
tree([X],X).
     
layer([X,Y|Bottom],[Z|Top?]) :-
          node(X,Y,Z),
          layer(Bottom?,Top).
layer([X],[X]).
layer([],[]).
     
     
node(     channel(UpXs,DownXs),
          channel(UpYs,DownYs),
          channel(UpZs,DownZs)
) :-
          merge(UpXs?,UpYs?,UpZs),
          distribute(DownZs?,DownXs,DownYs).
     
merge([X|Xs],Ys,[X|Zs]) :- merge(Ys?,Xs?,Zs).
merge(Xs,[Y|Ys],[Y|Zs]) :- merge(Ys?,Xs?,Zs).
merge([],[],[]).
     
     
distribute(         [message([0|To],From,Contents)|Zs],
                    [message(To,From,Contents)|Xs],
                    Ys
) :-
          distribute(Zs?,Xs,Ys).
distribute(         [message([1|To],From,Contents)|Zs],
                    Xs,
                    [message(To,From,Contents)|Ys]
) :-
          distribute(Zs?,Xs,Ys).
distribute([],[],[]).
     
     
     
/*
     
Example: An advanced mailer
     
     
mailer(Subscribers) :-
          Subscribers is a list of terms subscriber(Name,From,To),
          where Name is the name of the subscriber, From is
          a stream of messges from the subscriber, and to is
          the stream of messages to the subscriber.
          A legal message is of the form message(Name,Content).
     
The mailer performs message format verification, and returns
badly formatted messages, and messages with unknown destination.
It performs also sender authentication, since the return
address is generated by the mailer and not by the user.
*/
     
mailer(Subscribers) :-
          dictionary(Subscribers?,Channels,Paths,Dictionary),
          paths(Paths?),
          tree(Channels?,channel(In,Out)),
          route(In?,Out,Dictionary?).
     
dictionary(         [subscriber(Name,FromUser,ToUser)|Ss],
                    [channel(ToMailer,FromMailer)|Cs?],
                    [Path|Ps?],
                    [entry(Name?,Path?)|Es?]
) :-
          subscriber_manager(FromUser?,ToMailer,FromMailer?,ToUser),
          dictionary(Ss?,Cs,Ps,Es).
dictionary([],[],[],[]).
     
tree([X1,X2|Bottom],Top) :-
          layer([X1,X2|Bottom],Bottom1),
          tree(Bottom1?,Top).
tree([X],X).
     
layer([X,Y|Bottom],[Z|Top?]) :-
          node(X,Y,Z),
          layer(Bottom?,Top).
layer([X],[X]).
layer([],[]).
     
node(     channel(UpXs,DownXs),
          channel(UpYs,DownYs),
          channel(UpZs,DownZs)
) :-
          merge(UpXs?,UpYs?,UpZs),
          distribute(DownZs?,DownXs,DownYs).
     
     
/*
paths(Ps) :- Ps is the list of paths of the subscribers.
          Each path is a list of binary digits.
*/
     
paths([P1,P2|Paths]) :-
          bits([P1,P2|Paths?],Paths1),
          paths(Paths1?).
paths([[]]).
     
bits([],[]).
bits([Path],[Path]).
bits([Left,Right|Ps],[Parent|Ps1?]) :-
          append(Parent?,[0],Left),
          append(Parent?,[1],Right),
          bits(Ps?,Ps1).
     
     
merge(    [message(To,From,Contents)|Xs],
          Ys,
          [message(To,[0|From],Contents)|Zs]
) :-
          merge(Xs?,Ys?,Zs).
merge(    Xs,
          [message(To,From,Contents)|Ys],
          [message(To,[1|From],Contents)|Zs]
) :-
          merge(Xs?,Ys?,Zs).
merge([],[],[]).
     
     
distribute(         [message([0|To],From,Contents)|Zs],
                    [message(To,From,Contents)|Xs],
                    Ys
) :-
          distribute(Zs?,Xs,Ys).
distribute(         [message([1|To],From,Contents)|Zs],
                    Xs,
                    [message(To,From,Contents)|Ys]
) :-
           distribute(Zs?,Xs,Ys).
distribute([],[],[]).
     
route([message(To,FromPath,Contents)|In],[Message?|Out?],Dictionary) :-
           member(entry(To,ToPath),Dictionary?,Ok),
           member(entry(From,FromPath),Dictionary?,true),
           send(Ok?,To,ToPath,From,FromPath,Contents,Message),
           route(In?,Out,Dictionary).
     
send(     true,To,ToPath,From,FromPath,Contents,
          message(ToPath,From,Contents)
).
send(     false,To,ToPath,From,FromPath,Contents,
          message(FromPath,mailer,unknown_address(To,Contents))
).
     
/*
The subscriber manager initializes the return address to [],
and return badly formatted messages to the sender.
*/
     
subscriber_manager(
          [message(From,Content)|FromUser],
          [message(From,[],Content)|ToMailer],
          FromMailer,
          ToUser
) :-
          subscriber_manager(FromUser?,ToMailer,FromMailer?,ToUser).
subscriber_manager(
          [X|FromUser],
          ToMailer,
          FromMailer,
          [illegal_message(X)|ToUser]
) :-
          X=\=message(To,Content) |
          subscriber_manager(FromUser?,ToMailer,FromMailer?,ToUser).
subscriber_manager(
          FromUser,
          ToMailer,
          [X|FromMailer],
          [X|ToUser]
) :-
          subscriber_manager(FromUser?,ToMailer,FromMailer?,ToUser).
subscriber_manager([],[],[],[]).
     
     
member(X,[X|Xs],true).
member(X,[Y|Ys],Result) :-
           X=\=Y | member(X,Ys?,Result).
member(X,[],false).
     
append([X|Xs],Ys,[X|Zs]) :-
           append(Xs?,Ys,Zs).
append([],Ys,Ys).
     
     
/*
test_mailer(Names) :-
          Setting up the system so that it would be
          easy to test the mailer.  Names is a list of strings,
          which can be used as a destination for a message, e.g.
          john#message(jim,hi)
          simulates john sending a message to jim, assuming Names
          contained both.
*/
     
test_mailer(Names) :-
          make_subscribers(Names?,Ss),
          mailer(Ss?).
     
make_subscribers([Name|Ns],[subscriber(Name,In,Out)|Ss]) :-
          system#open_service(Name,In,[],Ok),
          Ok? = true,
          wrap(Name?,Out?,Out1),
          screen#display_stream(Out1),
          make_subscribers(Ns?,Ss).
make_subscribers([],[]).
     
close_subscribers([Name|Names]) :-
          system#close_service(Name,Ok),
          Ok? = true,
          close_subscribers(Names?).
close_subscribers([]).
     
wrap(Name,[X|Xs],[{Name,X}|Ys]) :-
          wrap(Name,Xs?,Ys).
wrap(Name,[],[]).
-------

