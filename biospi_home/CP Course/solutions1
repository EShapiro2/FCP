			Solutions to exercise1


1. Rules defining family relations.

1.1	{sibling(X,Y) | X and Y are siblings}

Using the usual definition of siblings, children with a common parent, first
define the auxiliary predicate parent/2.

	{parent(P,C) | P is a parent of C}

		parent(P,C) :-
			father(P,C).
		parent(P,C) :-
			mother(P,C).

Then sibling/2 is simply expressed by the logic program:

	sibling(X,Y) :-
		X =\= Y,
		parent(Z,X),
		parent(Z,Y).

The predicate  X =\= Y, expressed in infix notation, means:

	X is not equivalent to Y

as it was used in class.  If you didn't include a predicate like that, your
program could (probably) be used to prove sibling(X,X) - i.e. X is his/her own
sibling.


1.2	{procreated(X,Y) | X and Y have procreated}

Using the meaning of procreated, that X and Y are biological parents of a
child (and ignoring miracles of modern science):

	procreated(X,Y) :-
		father(X,C),
		mother(Y,C).
	procreated(X,Y) :-
		father(Y,C),
		mother(X,C).

A more concise alternative formulation is:

	procreated(X,Y) :-
		X =\= Y,
		parent(X,C),
		parent(Y,C).


1.3	{sister(X,Y) | X is a sister of Y}

	sister(X,Y) :-
		female(X),
		sibling(X,Y).

A body preficate  X =\= Y  is unnecessary, since it is implicit in sibling/2.


1.4	{ancestor(X,Y) | X is an ancestor of Y}

	ancestor(X,Y) :-
		parent(X,Y).
	ancestor(X,Y) :-
		parent(X,C),
		ancestor(C,Y).

Alternatively:

	ancestor(X,Y) :-
		parent(X,Y).
	ancestor(X,Y) :-
		parent(P,Y),
		ancestor(X,P).

2.	{above(X,Y) | X is above Y in a stack of blocks}

	above(X,Y) :-
		on(X,Y).
	above(X,Y) :-
		on(X,Z),
		above(Z,Y).

Note the resemblance to 1.d above.

3.	Assuming a unary representation of the natural numbers

3.1	{plus(X,Y,Z) | X plus Y equals Z}

	plus(0,X,X).
	plus(s(X),Y,Z) :-
		plus(X,s(Y),Z).

This procedure produces the sum Z all at once, when it terminates.  It can
also produce Y, the difference of X and Z, all at once, provided X >= Z, with
the declarative reading {plus(X,Y,Z) | Y is the difference of X and Z}.

An alternative:

	plus(0,X,X).
	plus(s(X),Y,s(Z)) :-
		plus(X,Y,Z).

produces the sum Z (or the difference Y) incrementally.  

Note that either procedure can be expressed symmetrically in the first two
arguments, reflecting the commutativity of addition.

3.2	less_than(X,Y) :- X is less than Y}

	less_than(0,s(X)).
	less_than(s(X),s(Y)) :-
		less_than(X,Y).

The apparent alternative:

	less_than(X,s(X)).
	less_than(X,Y) :-
		less_than(s(X),Y).

is non-terminating when X is originally greater-than or equal to Y - e.g.
the query less_than(0,0) will never terminate - its trace (in any
implementation) is:

	less_than(0,0)
	  less_than(s(0),0)
	    less_than(s(s(0)),0)
	      ...

This problem doesn't arise with the recursive procedures in 1 and 2 above,
since they operate on (implicitly) finite data-bases.

3.3	{even(X) | X is an even number}

	even(0).
	even(s(s(X)) :-
		even(X).

This solution is more economical (of tokens, clauses and reductions) than:

	even(0).
	even(s(X)) :-
		odd(X).

	odd(s(X)) :-
		even(X).

but the latter form provides an extra predicate, which may be useful.

3.4	{fib(N,F) | F is the Nth Fibonacci number}

	fib(0,0).
	fib(s(0),s(0)).
	fib(s(s(N)),FN2) :-
		fib(N,FN),
		fib(s(N),FN1),
		plus(FN,FN1,FN2).

4. Define predicates over lists.

4.1	{reverse(X,Y) | Y is the reverse of X}

The naive program requires an auxiliary predicate, append/3.

	{append(X,Y,Z) | Z is the list of the elements of list X followed
			 by the elements of list Y}

	append([],Y,Y).
	append([X|Xs],Ys,[X|Zs]) :-
		append(Xs,Ys,Zs).

	reverse([],[]).
	reverse([X|Xs],Zs) :-
		reverse(Xs,Ys),
		append(Ys,[X],Zs).

A more elegant program is:

	reverse(Xs,Zs) :-
		reverse(Xs,[],Zs).

	reverse([],Ys,Ys).
	reverse([X|Xs],Ys,Zs) :-
		reverse(Xs,[X|Ys],Zs).

Like the first program for plus/3, this program produces its result, the
reversed list, all at once when it terminates.

4.1	{sum(X,S) | S is the sum of the numbers in list X}

4.1.a	sum([],0).
	sum([X|Xs],S) :-
		sum(Xs,ST),
		plus(X,ST,S).

4.1.b	sum([],0).
	sum([0|Xs],S) :-
		sum(Xs,S).
	sum([s(X)|Xs],s(S)) :-
		sum([X|Xs],S).

5. Define predicates over trees of integers.

5.1	{subtree(X,T) | X is a subtree of tree T}

	subtree(X,X).
	subtree(X,tree(Left,Y,Right)) :-
		subtree(X,Left).
	subtree(X,tree(Left,Y,Right)) :-
		subtree(X,Right).

5.2	{insert(N,Tree,Tree1) | Tree1 is the result of inserting N into the
				ordered tree Tree}

	insert(N,nil,tree(nil,N,nil)).
	insert(N,tree(Left,N1,Right)) :-
		N1 >= N,
		insert(N,Left).
	insert(N,tree(Left,N1,Right)) :-
		N >= N1,
		insert(N,Right).

Note that Tree1 is defined ambiguously by this procedure - e.g. for Tree =
tree(nil,N,nil), N may be inserted either on the left or the right, giving:

either	insert(N, tree(nil,N,nil), tree(tree(nil,N,nil),N,nil))

or	insert(N, tree(nil,N,nil), tree(nil,N,tree(nil,N,nil)))
