-export([primes/2,msort/2,mm/3]).

/*

Concurrent Prolog Programming Techniques                       Fall, 1986
	
Instructor: William Silverman

Assignment No. 4  Solutions

     
(1) Sieve of Eratosthenes: The program shown in handout no. 4
 	uses division, whereas the standard sequential implementation
	(in Fortran, say) would use only addition.  Modify the
	program shown in the handout to use only addition.
	Hint: adding one argument to `filter' is enough.
*/


primes(N,Ps) :-
	integers(2,N,Ns),
	sift(Ns?,Ps).

% integers(N1,N2,Ns) :- Ns are the integers between N1 and N2, inclusive.

integers(N,N,[]).
integers(N1,N3,[N1|Ns]) :-
	N1 < N3 |
	N2:=N1+1,
	integers(N2?,N3?,Ns).

% sift(Ns,Ps) :- Ps are the Ns with non-primes removed.

sift([P|Ns],[P|Ps]) :-
	filter(Ns?,P,Ns1),
	sift(Ns1?,Ps).
sift([],[]).

% filter(In,P,Out) :- Out is the integers in In with multiples of P removed.

filter(In,P,Out) :-
	filter(In?,P?,P?,Out).

filter([X|In],P,S,[X|Out]) :-
	X < S |
	filter(In?,P,S,Out).
filter([X|In],P,S,Out) :-
	X =:= S |
	filter(In?,P,S,Out).
filter([X|In],P,S,Out) :-
	X > S |
	S1 := S + P,
	filter([X|In],P,S1?,Out).
filter([],P,S,[]).



/*       Sample Run

@solutions4#primes(60, Ps)
<1> started
loaded(solutions4) /fcp/users/bill/Bin/solutions4.bin
<1> ended
@Ps^
Ps = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]

     
(2) Merge sort:
    Define  	
	msort(ListOfXs,Ys) :-
	ListOfXs is a list of sorted lists (initially singleton
	lists), and Ys is the sorted list of their elements.
	Use a variant of opmerge (handout no. 5) to merge the sorted
	(sub)lists.
     
	E.g. msort([[2],[4],[3]],[2,3,4]).

*/

msort([X],X).
msort(Xs,Zs) :-
	Xs = [_,_|_] |
	merge_pairs(Xs,Ys),
	msort(Ys?,Zs).

merge_pairs([],[]).
merge_pairs([X],[X]).
merge_pairs([X1,X2|Xs],[Y?|Ys?]) :-
	merge2(X1?,X2?,Y),
	merge_pairs(Xs,Ys).

merge2([],X,X).
merge2(X,[],X).
merge2([X|Xs],[Y|Ys],[X|Zs?]) :-
	X =< Y |
	merge2(Xs,[Y|Ys],Zs).
merge2([X|Xs],[Y|Ys],[Y|Zs?]) :-
	X > Y |
	merge2([X|Xs],Ys,Zs).

/*                  Sample Run

@#msort([[2],[4],[3]], X1^)
<2> started
X1 / 1 = 2
X1 / 2 = 3
<2> ended
X1 / 3 = 4
X1 /   = []
@X1^
X1 = [2, 3, 4]
@#msort([[5,6,8],[2,45,99,125],[4,8,8,64],[0,17]],X2)
<3> started
<3> ended
@X2^
X2 = [0, 2, 4, 5, 6, 8, 8, 8, 17, 45, 64, 99, 125]
@#msort([X1,X2,Ps],X3)
<4> started
<4> ended
@X3^
X3 = [0, 2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 7, 8, 8, 8, 11, 13, 17, 17, 19, 23 | 
    ...]
@M1=[[1,2],[3,4]]
@M2=[[5,7],[6,0]]


     
(3) Matrix multiplication: modify the program shown in handout no. 5
	to pipeline both matrices between the inner-product processes.
	Hint: define an inner product process with five arguments:
	two input streams, two output streams, and a result.
*/

mm([],_,[]).
mm([Xv|Xm],Ym,[Zv|Zm]) :-
	vm(Xv?,Ym?,Zv,Ym1),
	mm(Xm?,Ym1?,Zm).

% vm(Xv,Ym,Zv,Ym2) :- multiplying the vector Xv by the matrix Ym gives
%                     the vector Zv, and a copy Ym of the matrix Ym.

vm(_,[],[],[]).
vm(Xv,[Yv|Ym],[Z|Zv],[Yv1|Ym1]) :-
	ip2(Xv?,Yv?,Z,Xv1,Yv1),
	vm(Xv1?,Ym?,Zv,Ym1).


% ip2(Xv,Yv,Z,Xv1,Yv1) :- Z is the inner product of Xv and Yv,
%                         Xv1 is a copy of Xv, and Yv1 is a copy of Yv.

ip2([X|Xv],[Y|Yv],S,[X|Xv1],[Y|Yv1]) :-
	ip2(Xv?,Yv?,S1,Xv1,Yv1),
	S := S1 + X*Y.
ip2([],[],0,[],[]).
	


/*                  Sample Run

@#mm(M1,M2,M12^)
<5> started
M12 / 1 = [19, 6]
M12 / 2 = [43, 18]
<5> ended
M12 /   = []
@M4=[[1,3,0],[2,1,4],[1,5,1]]
@M5=[[6,1,3],[0,2,2]]
@#mm(M4,M5,M45)
<6> started
<6> ended
@M45^
M45 = [[9, 6], [25, 10], [14, 12]]
@#mm(M5,M4,M54)
<7> started
<7> ended
@M54^
M54 = [[9, 25, 14], [6, 10, 12]]
@M54 = [[9, 25, 14], [6, 10, 12]]
@#mm(M1,M4,Mbad)
<8> started
<8> failed(solutions4 # ip2([], [0], _X0, _X1, _X2))

*/
